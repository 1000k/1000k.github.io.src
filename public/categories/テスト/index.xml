<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>テスト on 1000g</title>
    <link>http://1000k.github.io/categories/%E3%83%86%E3%82%B9%E3%83%88/</link>
    <description>Recent content in テスト on 1000g</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Thu, 22 May 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://1000k.github.io/categories/%E3%83%86%E3%82%B9%E3%83%88/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Protractor が動かなくてハマった</title>
      <link>http://1000k.github.io/2014/05/22/protractor-doesnt-work-for-me/</link>
      <pubDate>Thu, 22 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://1000k.github.io/2014/05/22/protractor-doesnt-work-for-me/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/angular/angular-seed&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;https://github.com/angular/angular-seed&#39;, &#39;angular-seed&#39;]);&#34; &gt;angular-seed&lt;/a&gt; を使って Angular.js の開発環境を作成していたのですが、どうにもこうにも e2e テストが動かなくてハマりました。&lt;/p&gt;

&lt;p&gt;エラーメッセージは以下のとおり。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm run protractor

&amp;gt; angular-seed@0.0.0 preprotractor /var/www
&amp;gt; npm run update-webdriver


&amp;gt; angular-seed@0.0.0 preupdate-webdriver /var/www
&amp;gt; npm install


&amp;gt; angular-seed@0.0.0 postinstall /var/www
&amp;gt; bower install


&amp;gt; angular-seed@0.0.0 update-webdriver /var/www
&amp;gt; webdriver-manager update

selenium standalone is up to date.
chromedriver is up to date.

&amp;gt; angular-seed@0.0.0 protractor /var/www
&amp;gt; protractor test/protractor-conf.js


------------------------------------
PID: 2314 (capability: chrome #1)
------------------------------------

Starting selenium standalone server...

events.js:72
        throw er; // Unhandled &#39;error&#39; event
              ^
Error: spawn ENOENT
    at errnoException (child_process.js:998:11)
    at Process.ChildProcess._handle.onexit (child_process.js:789:34)
[launcher] Runner Process Exited With Error Code: 8

npm ERR! angular-seed@0.0.0 protractor: `protractor test/protractor-conf.js`
npm ERR! Exit status 1
npm ERR!
npm ERR! Failed at the angular-seed@0.0.0 protractor script.
npm ERR! This is most likely a problem with the angular-seed package,
npm ERR! not with npm itself.
npm ERR! Tell the author that this fails on your system:
npm ERR!     protractor test/protractor-conf.js
npm ERR! You can get their info via:
npm ERR!     npm owner ls angular-seed
npm ERR! There is likely additional logging output above.
npm ERR! System Linux 3.13.0-24-generic
npm ERR! command &amp;quot;node&amp;quot; &amp;quot;/usr/bin/npm&amp;quot; &amp;quot;run&amp;quot; &amp;quot;protractor&amp;quot;
npm ERR! cwd /var/www
npm ERR! node -v v0.10.28
npm ERR! npm -v 1.4.10
npm ERR! code ELIFECYCLE
npm ERR!
npm ERR! Additional logging details can be found in:
npm ERR!     /var/www/npm-debug.log
npm ERR! not ok code 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;code ELIFECYCLE&lt;/code&gt; が何を意味しているのかさっぱりわからず途方に暮れていましたが、結局のところ Java に PATH が通っていなかったのが原因だったようです。&lt;/p&gt;

&lt;p&gt;e2e テストは内部で Selenium Standalone Server を呼んでいますが、そこに Java が必要でした。&lt;/p&gt;

&lt;p&gt;単純に OpenJDK をパッケージインストールするだけで解決しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install openjdk-7-jre-headless
$ java -version
(バージョンが表示されれば PATH が通ってるので OK)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Node.js はデバッグメッセージが雑なことが多いので苦手です。&lt;/p&gt;

&lt;h2 id=&#34;参考:44911033301877b7be87059dd5b5c5f6&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/20188679/how-to-run-protractor/23772014#23772014&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://stackoverflow.com/questions/20188679/how-to-run-protractor/23772014#23772014&#39;, &#39;angularjs &amp;#8211; How to run protractor? &amp;#8211; Stack Overflow&#39;]);&#34; &gt;angularjs &amp;#8211; How to run protractor? &amp;#8211; Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>PHPUnit の Expectation を簡潔に書く TIPS</title>
      <link>http://1000k.github.io/2013/09/24/tips-to-simplify-writing-expection-of-phpunit/</link>
      <pubDate>Tue, 24 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>http://1000k.github.io/2013/09/24/tips-to-simplify-writing-expection-of-phpunit/</guid>
      <description>

&lt;p&gt;PHPUnit の小ネタです。&lt;/p&gt;

&lt;p&gt;PHPUnit でモックを使ったテストケースを書くと、以下のように記述量が多くなってうんざりします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
class FooClassTest extends PHPUnit_Framework_TestCase {
    /**
     * @covers FooClass::doSomething
     */
    public function testDoSomething() {
        // FooClass が依存している BarClass のモックを作る。
        // 何もしないように、__construct() と __clone() は無効化しておく。
        $mockBar = $this-&amp;gt;getMockBuilder(&#39;BarClass&#39;)
            -&amp;gt;disableOriginalConstructor()
            -&amp;gt;disableOriginalClone()
            -&amp;gt;getMock();

        // BarClass::barMethod のモックの挙動を変える。
        $mockBar-&amp;gt;expect($this-&amp;gt;any())
            -&amp;gt;method(&#39;barMethod&#39;)
            -&amp;gt;will($this-&amp;gt;returnValue(true));

        $object = new FooClass($mockBar);

        $this-&amp;gt;assertTrue($object-&amp;gt;doSomething());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;長い、書きづらい、読みづらい。こんなテストケース、2つ以上書きたくないですね。もっと楽に書くための TIPS をメモしておきます。&lt;/p&gt;

&lt;p&gt;まず、何もしない「プレーンな」モックオブジェクトを作るメソッドを作りましょう。&lt;code&gt;PHPUnit_Framework_TestCase&lt;/code&gt; を継承した &lt;code&gt;MyTestCase&lt;/code&gt; に実装してやります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MyTestCase extends PHPUnit_Framework_TestCase {

    /**
     * 元のクラスが完全に何もしないよう擬装したモックを作成する。
     *
     * - コンストラクタが無効
     * - クローンコンストラクタが無効
     *
     * @param string $class_name
     * @return mixed 指定したクラスのモック
     * @throws InvalidArgumentException 指定したクラス名が見つからない場合
     */
    protected function _getPlainMock($class_name) {
        if (!class_exists($class_name)) {
            throw new InvalidArgumentException(&amp;quot;{$class_name} does not exist.&amp;quot;);
        }

        return $this-&amp;gt;getMockBuilder($class_name)
            -&amp;gt;disableOriginalConstructor()
            -&amp;gt;disableOriginalClone()
            -&amp;gt;getMock();
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、PHPUnit の Expectation はメソッドチェーンで連続して指定できます (&amp;#8220;-&amp;gt;&amp;#8221; 演算子で繋げて書ける) が、そもそも記述量が多いです。いちいち this this 書くのも煩わしい。&lt;/p&gt;

&lt;p&gt;そこで、Expectation をセットするためのメソッドを作ってやると楽になります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
    /**
     * モックオブジェクトに Expectation を設定する。
     *
     * @param Object &amp;amp;#038;$mock モックオブジェクト
     * @param string $matcher マッチャー ([any|once|never|...])
     * @param string $method メソッド名
     * @param mixed $return_value 期待する戻り値
     */
    protected function _setExpectation(&amp;amp;#038;$mock, $matcher, $method, $return_value = null) {
        $mock-&amp;gt;expects($this-&amp;gt;$matcher())
            -&amp;gt;method($method)
            -&amp;gt;will($this-&amp;gt;returnValue($return_value));
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを使うと、一番最初のテストケースは以下のように書き直せます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require_once &#39;MyTestCase.php&#39;;

class FooClassTest extends MyTestCase {
    /**
     * @covers FooClass::doSomething
     * @test
     */
    function doSomething() {
        $mockBar = $this-&amp;gt;_getPlainMock(&#39;BarClass&#39;)
        $this-&amp;gt;_setExpectation($mockBar, &#39;any&#39;, &#39;barMethod&#39;, true);

        $object = new FooClass($mockBar);

        $this-&amp;gt;assertTrue($object-&amp;gt;doSomething());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;簡単になりましたね！9行もあったコードが4行に減りました。&lt;/p&gt;

&lt;p&gt;ちなみに、さり気なくテストケースの &lt;code&gt;public&lt;/code&gt; は削除しています。PHP の仕様上、public なメソッドはわざわざそれを書く必要がありません。&lt;/p&gt;

&lt;p&gt;また、PHPDoc 部分に &lt;code&gt;@test&lt;/code&gt; アノテーションを付けると、メソッド名を &lt;code&gt;test&lt;/code&gt; で始めなくてもテストケースとして認識されるようになります。私はこの方が読みやすいので、最近はこう書くことが多いです。&lt;/p&gt;

&lt;p&gt;こういう改善をしても、Ruby に慣れているとまだ長く感じます。「$」「&amp;#8217;」「&amp;gt;」などの記号を打つのも煩わしいです。Ruby 使いてえなあ。&lt;/p&gt;

&lt;h2 id=&#34;参考:66eb9e16e3cbfb7a24c972ec7c7d6f12&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://phpunit.de/manual/3.8/ja/test-doubles.html&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://phpunit.de/manual/3.8/ja/test-doubles.html&#39;, &#39;PHPUnit 公式マニュアル &gt; 第10章 テストダブル&amp;rsquo;]);&amp;rdquo; &amp;gt;PHPUnit 公式マニュアル &amp;gt; 第10章 テストダブル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://phpunit.de/manual/3.8/ja/appendixes.annotations.html&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://phpunit.de/manual/3.8/ja/appendixes.annotations.html&#39;, &#39;付録B アノテーション&#39;]);&#34; &gt;付録B アノテーション&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>jenkins ユーザーが ant を実行できないときの対処法</title>
      <link>http://1000k.github.io/2013/07/02/jenkins-user-cannot-run-ant/</link>
      <pubDate>Tue, 02 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>http://1000k.github.io/2013/07/02/jenkins-user-cannot-run-ant/</guid>
      <description>

&lt;p&gt;CentOS 6.3 にて、&lt;a href=&#34;http://jenkins-php.org/&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://jenkins-php.org/&#39;, &#39;Template for Jenkins Jobs for PHP Projects&#39;]);&#34; &gt;Template for Jenkins Jobs for PHP Projects&lt;/a&gt; にある ant タスク (build.xml) 通りに PHPUnit タスクを実行しようとしたら、エラーが出てしまいました。&lt;/p&gt;

&lt;p&gt;かなり長時間ハマったのでメモを残しておきます。&lt;/p&gt;

&lt;h2 id=&#34;症状:135291858de89f6329950b22fca515d3&#34;&gt;症状&lt;/h2&gt;

&lt;p&gt;CentOS 6.3 にて、&lt;a href=&#34;http://jenkins-php.org/&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://jenkins-php.org/&#39;, &#39;Template for Jenkins Jobs for PHP Projects&#39;]);&#34; &gt;Template for Jenkins Jobs for PHP Projects&lt;/a&gt; にある以下のタスクを実行するとエラーが出ました。&lt;code&gt;
 &amp;lt;target name=&amp;quot;phpunit&amp;quot; description=&amp;quot;Run unit tests using PHPUnit and generates junit.xml and clover.xml&amp;quot;&amp;gt; &amp;lt;exec executable=&amp;quot;phpunit&amp;quot; failonerror=&amp;quot;true&amp;quot;/&amp;gt; &amp;lt;/target&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;エラーメッセージ:&lt;code&gt;
 # sudo -u jenkins ant ... phpunit: BUILD FAILED /var/lib/jenkins/jobs/mojamoja-unit-testing/workspace/build.xml:22: Execute failed: java.io.IOException: Cannot run program &amp;quot;phpunit&amp;quot;: error=2, No such file or directory Total time: 0 seconds&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;原因:135291858de89f6329950b22fca515d3&#34;&gt;原因&lt;/h2&gt;

&lt;p&gt;どうやら phpunit へのパスが通っていないようです。&lt;/p&gt;

&lt;p&gt;phpunit の実体は &lt;code&gt;/usr/local/bin/phpunit&lt;/code&gt; なのですが、jenkins ユーザーがこの PATH を参照できていない模様。&lt;/p&gt;

&lt;h2 id=&#34;試行錯誤:135291858de89f6329950b22fca515d3&#34;&gt;試行錯誤&lt;/h2&gt;

&lt;p&gt;まず、jenkins ユーザーの &lt;code&gt;~/.bash_profile&lt;/code&gt; と &lt;code&gt;~/.bashrc&lt;/code&gt; を以下の内容で作成してもダメでした。PATH は反映されません。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
export PATH=$PATH:/usr/local/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、下記のように ant タスク内で PATH を変更するシェルを走らせてもダメでした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;lt;target name=&amp;quot;setenv&amp;quot;&amp;gt;
   &amp;amp;lt;exec executable=&amp;quot;/bin/sh&amp;quot;&amp;gt;
     &amp;amp;lt;arg line=&amp;quot;./setenv.sh&amp;quot;/&amp;gt;
   &amp;amp;lt;/exec&amp;gt;
 &amp;amp;lt;/target&amp;gt;

 &amp;amp;lt;target name=&amp;quot;env&amp;quot;&amp;gt;&amp;amp;lt;exec executable=&amp;quot;env&amp;quot; /&amp;gt;&amp;amp;lt;/target&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;setenv.sh の中身は下記。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh
export PATH=${PATH}:/usr/local/bin
echo $PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで ant を実行すると、&lt;code&gt;setenv&lt;/code&gt; タスクの時点では PATH は変更されていますが、次に実行される &lt;code&gt;env&lt;/code&gt; タスクで元に戻ってしまっています。まるで setenv と env が別々のプロセスで動いているように見えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Buildfile: build.xml

setenv:
     [exec] /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin

env:
     [exec] HOSTNAME=mojamoja
     [exec] SHELL=/bin/bash
     [exec] TERM=xterm
     [exec] HISTSIZE=1000
     [exec] USER=jenkins
     ...
     [exec] PATH=/sbin:/bin:/usr/sbin:/usr/bin      &amp;amp;lt;- /usr/local/bin が追加されていない
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とういわけで、setenv で環境変数をセットする方法はボツでした。&lt;/p&gt;

&lt;h2 id=&#34;解決方法:135291858de89f6329950b22fca515d3&#34;&gt;解決方法&lt;/h2&gt;

&lt;h3 id=&#34;1-jenkins-のグローバルプロパティを設定する:135291858de89f6329950b22fca515d3&#34;&gt;1. Jenkins のグローバルプロパティを設定する&lt;/h3&gt;

&lt;p&gt;Jenkins から環境変数を上書きすることで、PATH を追加することができます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Jenkinsの管理 &amp;gt; システムの設定 &amp;gt; グローバルプロパティ &amp;gt; 環境変数&lt;/code&gt; にて、以下のように設定します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.1000k.net/wp-content/uploads/jenkins_global_property.png&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://blog.1000k.net/wp-content/uploads/jenkins_global_property.png&#39;, &#39;&#39;]);&#34; &gt;&lt;img src=&#34;http://blog.1000k.net/wp-content/uploads/jenkins_global_property-300x191.png&#34; alt=&#34;Jenkins グローバルプロパティ&#34; width=&#34;300&#34; height=&#34;191&#34; class=&#34;alignnone size-medium wp-image-1507&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;キー: &lt;code&gt;PATH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;値: &lt;code&gt;${PATH}:/usr/local/bin&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ただし、この方法だと Jenkins から Ant を実行した時しか PATH は上書きされません。&lt;/p&gt;

&lt;h3 id=&#34;2-sudoers-の-secure-path-を無効にする:135291858de89f6329950b22fca515d3&#34;&gt;2. sudoers の secure_path を無効にする&lt;/h3&gt;

&lt;p&gt;Fedora 系では sudo ユーザー向けの PATH が &lt;code&gt;/sbin:/bin:/usr/sbin:/usr/bin&lt;/code&gt; のみに制限されているので、これを外してやります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;visudo&lt;/code&gt; コマンドを実行して、以下のように書き直します。&lt;code&gt;
 # secure\_path をコメントアウト # Defaults secure\_path = /sbin:/bin:/usr/sbin:/usr/bin # env\_keep に PATH を追加 Defaults env\_keep += &amp;quot;PATH&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;これで secure_path の縛りが解除されました。&lt;/p&gt;

&lt;p&gt;sudoers の環境変数は `sudo -l` で確認できます。&lt;code&gt;
 # sudo -l Matching Defaults entries for root on this host: !visiblepw, always\_set\_home, env\_reset, env\_keep=&amp;quot;COLORS DISPLAY HOSTNAME HISTSIZE INPUTRC KDEDIR LS\_COLORS&amp;quot;, env\_keep+=&amp;quot;MAIL PS1 PS2 QTDIR USERNAME LANG LC\_ADDRESS LC\_CTYPE&amp;quot;, env\_keep+=&amp;quot;LC\_COLLATE LC\_IDENTIFICATION LC\_MEASUREMENT LC\_MESSAGES&amp;quot;, env\_keep+=&amp;quot;LC\_MONETARY LC\_NAME LC\_NUMERIC LC\_PAPER LC\_TELEPHONE&amp;quot;, env\_keep+=&amp;quot;LC\_TIME LC\_ALL LANGUAGE LINGUAS \_XKB\_CHARSET XAUTHORITY&amp;quot;, env_keep+=PATH User root may run the following commands on this host: (ALL) ALL&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;参考:135291858de89f6329950b22fca515d3&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://deginzabi163.wordpress.com/2011/04/23/%E8%A6%9A%E6%9B%B8fedora-14%E3%81%AEsudo%E3%81%8Cpath%E7%92%B0%E5%A2%83%E5%A4%89%E6%95%B0%E3%82%92%E6%BD%B0%E3%81%99%E3%81%AE%E3%81%8C%E9%AC%B1%E9%99%B6%E3%81%97%E3%81%84%EF%BC%86%E5%AF%BE%E7%AD%96/&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://deginzabi163.wordpress.com/2011/04/23/%E8%A6%9A%E6%9B%B8fedora-14%E3%81%AEsudo%E3%81%8Cpath%E7%92%B0%E5%A2%83%E5%A4%89%E6%95%B0%E3%82%92%E6%BD%B0%E3%81%99%E3%81%AE%E3%81%8C%E9%AC%B1%E9%99%B6%E3%81%97%E3%81%84%EF%BC%86%E5%AF%BE%E7%AD%96/&#39;, &#39;[覚書]Fedora 14のsudoでPATHがアレで鬱陶しい＆対策 | Deginzabi163\&#39;s Blog&#39;]);&#34; &gt;[覚書]Fedora 14のsudoでPATHがアレで鬱陶しい＆対策 | Deginzabi163&amp;rsquo;s Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fishrimper.blogspot.jp/2012/12/sudo-path.html&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://fishrimper.blogspot.jp/2012/12/sudo-path.html&#39;, &#39;IT とかその他もろもろ: sudo した時の PATH&#39;]);&#34; &gt;IT とかその他もろもろ: sudo した時の PATH&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://superuser.com/questions/98686/passing-path-through-sudo&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://superuser.com/questions/98686/passing-path-through-sudo&#39;, &#39;linux - Passing PATH through sudo - Super User&#39;]);&#34; &gt;linux - Passing PATH through sudo - Super User&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>vfsStream の使い方</title>
      <link>http://1000k.github.io/2013/03/27/usage-of-vfsstream/</link>
      <pubDate>Wed, 27 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>http://1000k.github.io/2013/03/27/usage-of-vfsstream/</guid>
      <description>

&lt;p&gt;PHPUnit でファイルシステムのテストを行うとき便利な &lt;a href=&#34;http://vfs.bovigo.org/&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://vfs.bovigo.org/&#39;, &#39;vfsStream&#39;]);&#34; &gt;vfsStream&lt;/a&gt; ですが、簡単なサンプルがあまり無かったので書いてみました。&lt;/p&gt;

&lt;h2 id=&#34;vfsstream-とは:1bb7a2da6956cd5c18323dac9c2045f6&#34;&gt;vfsStream とは？&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ファイルの読み書きをテストする時に使うフレームワーク。&lt;/li&gt;
&lt;li&gt;仮想ファイルシステムを作成し、その中でディレクトリやファイルを操作できる。

&lt;ul&gt;
&lt;li&gt;実ファイルシステム: &lt;em&gt;file://&amp;#8230;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;仮想ファイルシステム: &lt;em&gt;vfs://&amp;#8230;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;実ファイルを作成せずにテストできるので、テストファイルが散らばる可能性が無く、前回のテストのゴミを意識せずに済む。&lt;/li&gt;
&lt;li&gt;ディレクトリやファイルの権限/ユーザー/オーナーも再現可能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;インストール方法:1bb7a2da6956cd5c18323dac9c2045f6&#34;&gt;インストール方法&lt;/h2&gt;

&lt;p&gt;詳しくは以前書いた &lt;a href=&#34;http://blog.1000k.net/2012/09/04/vfsstream%E3%82%92%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%81%99%E3%82%8B/&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://blog.1000k.net/2012/09/04/vfsstream%E3%82%92%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%81%99%E3%82%8B/&#39;, &#39;vfsStreamをインストールする | 1000g&#39;]);&#34; &gt;vfsStreamをインストールする | 1000g&lt;/a&gt; を参照。&lt;/p&gt;

&lt;h3 id=&#34;php-5-3-の場合:1bb7a2da6956cd5c18323dac9c2045f6&#34;&gt;PHP &amp;lt; 5.3 の場合&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ pear channel-discover pear.bovigo.org
$ pear install bovigo/vfsStream-beta
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;php-5-3-の場合-1:1bb7a2da6956cd5c18323dac9c2045f6&#34;&gt;PHP &amp;gt;= 5.3 の場合&lt;/h3&gt;

&lt;p&gt;composer.json に以下のように書く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;mikey179/vfsStream&amp;quot;: &amp;quot;v1.1.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用可能なバージョンは &lt;a href=&#34;https://packagist.org/packages/mikey179/vfsStream&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;https://packagist.org/packages/mikey179/vfsStream&#39;, &#39;mikey179/vfsStream &amp;#8211; Packagist&#39;]);&#34; &gt;mikey179/vfsStream &amp;#8211; Packagist&lt;/a&gt; を参照。&lt;/p&gt;

&lt;h2 id=&#34;サンプルコード:1bb7a2da6956cd5c18323dac9c2045f6&#34;&gt;サンプルコード&lt;/h2&gt;

&lt;p&gt;単純にファイルにテキストを追記するだけのロガーをテストしてみます。&lt;/p&gt;

&lt;p&gt;なお、vfsStream 0.12 を利用しています。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Logger.php&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Class Logger {
  public static function log($str, $path) {
    return file_put_contents($path, $str);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;LoggerTest.php&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require_once &#39;Logger.php&#39;;
require_once &#39;vfsStream/vfsStream.php&#39;;

class LoggerTest extends PHPUnit_Framework_Test {
    /**
     * @var vfsStreamDirectory
     */
    private $root;

    protected function setUp() {
        // 仮想ファイルシステムにルートディレクトリを作る。
        $this-&amp;gt;root = vfsStream::setup();     // &amp;quot;vfs://root&amp;quot; ディレクトリが作成される

        // ファイルのパスは vfsStream::url() で取得する。
        var_dump(vfsStream::url(&#39;root&#39;));         // =&amp;gt; vfs://root
        var_dump(is_dir(vfsStream::url(&#39;root&#39;))); // =&amp;gt; true
    }

    /**
     * @covers Logger::log
     */
    public function testLog() {
        $str = &#39;Lorem ipsum&#39;;
        $path = vfsStream::url(&#39;root/foo.txt&#39;);

        $this-&amp;gt;assertGreaterThan(0, Logger::log($str, $path));
        $this-&amp;gt;assertEquals($str, file_get_contents($path));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考:1bb7a2da6956cd5c18323dac9c2045f6&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tech.vg.no/2011/03/09/mocking-the-file-system-using-phpunit-and-vfsstream/&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://tech.vg.no/2011/03/09/mocking-the-file-system-using-phpunit-and-vfsstream/&#39;, &#39;Mocking the file system using PHPUnit and vfsStream – VG Tech&#39;]);&#34; &gt;Mocking the file system using PHPUnit and vfsStream – VG Tech&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;vfsStream を使った様々なテストのサンプルがあります。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mikey179/vfsStream/wiki&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;https://github.com/mikey179/vfsStream/wiki&#39;, &#39;Home · mikey179/vfsStream Wiki&#39;]);&#34; &gt;Home · mikey179/vfsStream Wiki&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;作成元の GitHub ページ。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.phpunit.de/manual/current/ja/test-doubles.html&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://www.phpunit.de/manual/current/ja/test-doubles.html&#39;, &#39;第10章 テストダブル&#39;]);&#34; &gt;第10章 テストダブル&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;PHPUnit のドキュメント内にある解説。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>依存性注入の解説とやり方</title>
      <link>http://1000k.github.io/2012/10/24/lecture-of-dependency-injection/</link>
      <pubDate>Wed, 24 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>http://1000k.github.io/2012/10/24/lecture-of-dependency-injection/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;依存性注入 (Dependency Injection)&lt;/strong&gt; は、クラスを単体テスト可能にするために使われるテクニックです。&lt;/p&gt;

&lt;p&gt;これが意識されていないが故に単体テストが全くできないコードをよく見かけます。&lt;/p&gt;

&lt;p&gt;単体テストの際には必ず必要になる知識なので、解説しておきます。&lt;/p&gt;

&lt;p&gt;以下のサンプルでは &lt;a href=&#34;http://www.phpunit.de/manual/3.8/ja/index.html&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://www.phpunit.de/manual/3.8/ja/index.html&#39;, &#39;PHPUnit&#39;]);&#34; &gt;PHPUnit&lt;/a&gt; を利用しています。&lt;/p&gt;

&lt;h2 id=&#34;単体テストができないケース:d011759973daaf90efe485c60339885a&#34;&gt;単体テストができないケース&lt;/h2&gt;

&lt;p&gt;例えば以下のメソッド Foo::play() は単体テストケースが書けません。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Foo {
    public function play() {
        $bar = new Bar();

        if ($bar-&amp;gt;getSomething() === 1) {
            return true;
        }

        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;play() 内で外部クラス Bar をインスタンス化しています。つまり Foo::play() メソッドは Bar クラスに&lt;strong&gt;依存&lt;/strong&gt;しており、単体テストができません。&lt;/p&gt;

&lt;p&gt;このまま無理矢理テストケースを書くと、以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class FooTest {
    /**
     * @covers Foo::play
     */
    public function testPlay() {
        $foo = new Foo;
        $this-&amp;gt;assertTrue($this-&amp;gt;foo-&amp;gt;play());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;何が問題かわかるでしょうか？Foo クラスのテスト結果は Bar クラスに依存してしまっています。つまり、Foo は何も変更していなくても、Bar を変更したタイミングで Foo の単体テストが壊れてしまう可能性があります。これでは結合テストであり、単体テストになっていません。&lt;/p&gt;

&lt;p&gt;そのため、通常は Bar クラスを&lt;strong&gt;モック化&lt;/strong&gt;し、Bar クラスの実装を無視できるようにします。&lt;/p&gt;

&lt;h2 id=&#34;モック化とは:d011759973daaf90efe485c60339885a&#34;&gt;モック化とは？&lt;/h2&gt;

&lt;p&gt;モック化とは、クラスの挙動を置き換えることです。例えば特定のメソッドの戻り値を好きな値に指定することができます。&lt;/p&gt;

&lt;p&gt;今回のケースでは、Bar::getSomething() が常に 1 を返すようにすれば、「return true」の行が実行されることをテストできますし、1 以外を返すようにすれば「return false」の行が実行されることをテストできます。&lt;/p&gt;

&lt;p&gt;しかし先述のコードのままでは、テスト対象のメソッド内で Bar をインスタンス化しているため、モックを注入する手段がありません。&lt;/p&gt;

&lt;p&gt;まだピンと来ない方も、この先の具体例を見ればイメージが掴めると思います。&lt;/p&gt;

&lt;h2 id=&#34;メソッドを単体テスト可能にする:d011759973daaf90efe485c60339885a&#34;&gt;メソッドを単体テスト可能にする&lt;/h2&gt;

&lt;p&gt;もしメソッドが下記のようになっていればどうでしょうか？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function play(Bar $bar) {     // Bar クラスのインスタンスを受け取るようにした。
        if ($bar-&amp;gt;getSomething() === 1) {
            return true;
        }

        return false;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;メソッド内で Bar クラスを new するのでなく、Bar インスタンスを引数に受け取って利用するだけにしました。これならテストケースでモックを注入することができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function testPlay() {
        $foo = new Foo;

        $bar = $this-&amp;gt;getMock(&#39;Bar&#39;);         // Bar クラスのモックを作成する。
        $bar-&amp;gt;expects($this-&amp;gt;any())
            -&amp;gt;method(&#39;getSomething&#39;)
            -&amp;gt;will($this-&amp;gt;returnValue(1));    // Bar::getSomething() の戻り値が 1 になるよう設定する。

        $this-&amp;gt;assertTrue($foo-&amp;gt;play($bar));  // Foo::play() に注入
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Foo::play() メソッドは Bar クラスとの依存が解消され、単体テストが可能になりました。これでもう Bar クラスの実装を変更しても Foo クラスのテストが壊れることはありません。これが&lt;strong&gt;依存性注入&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;これはメソッドの引数にオブジェクトを渡せるようにする手法で、&lt;strong&gt;インターフェース・インジェクション&lt;/strong&gt; (Interface Injection) と呼ばれます。&lt;/p&gt;

&lt;p&gt;（※厳密なインターフェース・インジェクションでは、まずクラスの interface を作成し、それを委譲したメソッドを実装する必要があります。上記の例では簡略化のため interface は作成していません。）&lt;/p&gt;

&lt;h2 id=&#34;コンストラクター-インジェクション:d011759973daaf90efe485c60339885a&#34;&gt;コンストラクター・インジェクション&lt;/h2&gt;

&lt;p&gt;依存性注入は以下のようなやり方でも実現が可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Foo {
    /** @var Bar */
    protected $bar;

    public function __constructor(Bar $bar = null) {
        // メンバ変数として Bar インスタンスを作成しておく。
        $this-&amp;gt;bar = $bar ? $bar : new Bar;
    }

    public function play() {
        // メンバ変数の Bar インスタンスからメソッドを呼び出す。
        if ($this-&amp;gt;bar-&amp;gt;getSomething() === 1) {
            return true;
        }

        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このケースでは、Foo クラスのコンストラクタに Bar クラスのオブジェクトを渡せるようにしています。これは&lt;strong&gt;コンストラクター・インジェクション&lt;/strong&gt; (Constructor Injection) と呼ばれるテクニックです。&lt;/p&gt;

&lt;p&gt;この場合のテストケースは以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function testPlay() {
        // Bar クラスのモックを作成する。
        $bar = $this-&amp;gt;getMock(&#39;Bar&#39;);
        $bar-&amp;gt;expects($this-&amp;gt;any())
            -&amp;gt;method(&#39;getSomething&#39;)
            -&amp;gt;will($this-&amp;gt;returnValue(1));

        $foo = new Foo($bar);   // Constructor Injection でモックを注入する。

        $this-&amp;gt;assertTrue($foo-&amp;gt;play($bar));
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;※コンストラクタ内の3項演算子について補足。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function __constructor(Bar $bar = null) {
        $this-&amp;gt;bar = $bar ? $bar : new Bar;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンストラクタの引数に $bar が渡されなかった時はデフォルトの Bar クラスを new するようにしています。これにより、テストの時はモックを注入して使うようにし、本番コードではパラメータを何も指定しないことでデフォルトの Foo クラスを使うようにしています。&lt;/p&gt;

&lt;h2 id=&#34;セッター-インジェクション:d011759973daaf90efe485c60339885a&#34;&gt;セッター・インジェクション&lt;/h2&gt;

&lt;p&gt;別のアプローチとして、クラスにオブジェクトを注入するためセッターメソッドを用意する方法もあります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Foo {
    /** @var Bar */
    protected $bar;

    /**
     * セッターメソッド
     *
     * @param Bar $bar
     */
    public function setBar(Bar $bar) {
        $this-&amp;gt;bar = $bar;
    }

    public function play() {
        if ($this-&amp;gt;bar-&amp;gt;getSomething() === 1) {
            return true;
        }

        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンストラクターで Bar インスタンスを注入するのでなく、setBar() メソッドで Bar オブジェクトを注入しています。&lt;/p&gt;

&lt;p&gt;この場合のテストケースは以下のようになるでしょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function testPlay() {
        // Bar クラスのモックを作成する。
        $bar = $this-&amp;gt;getMock(&#39;Bar&#39;);
        $bar-&amp;gt;expects($this-&amp;gt;any())
            -&amp;gt;method(&#39;getSomething&#39;)
            -&amp;gt;will($this-&amp;gt;returnValue(1));

        $foo = new Foo;
        $foo-&amp;gt;setBar($bar);     // セッター経由でモックを注入する。

        $this-&amp;gt;assertTrue($foo-&amp;gt;play($bar));
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これが&lt;strong&gt;セッター・インジェクション&lt;/strong&gt; (Setter Injection) です。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:d011759973daaf90efe485c60339885a&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;単体テストしたければ、メソッド内で外部クラスを new してはいけない。&lt;/li&gt;
&lt;li&gt;モックを注入可能にするためには、以下のいずれか手法を採る。

&lt;ul&gt;
&lt;li&gt;メソッドの引数に使いたいオブジェクトを渡せるようにする。 (Interface Injection)&lt;/li&gt;
&lt;li&gt;使う予定のオブジェクトをコンストラクタに渡せるようにする。(Constructor Injection)&lt;/li&gt;
&lt;li&gt;オブジェクトを setter メソッドで渡せるようにする。(Setter Injection)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;補足1-runkitで強引にメソッドの挙動を変える方法:d011759973daaf90efe485c60339885a&#34;&gt;補足1: runkitで強引にメソッドの挙動を変える方法&lt;/h2&gt;

&lt;p&gt;PHPにおいては &lt;a href=&#34;http://php.net/manual/ja/book.runkit.php&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://php.net/manual/ja/book.runkit.php&#39;, &#39;runkit&#39;]);&#34; &gt;runkit&lt;/a&gt; を使うことで、モック化をしなくてもメソッドの挙動を強引に変えることが可能です。ただし破壊的な手段であり、これが必要な時点でオブジェクト指向的な設計ができていない疑いが非常に強いです。&lt;/p&gt;

&lt;p&gt;できるだけ Constructor Injection 等の方法を用い、テスト可能になるようリファクタリングをしましょう。リファクタリング中はコードが醜くなるかもしれませんが、最終的に設計が改善できるならば結果OKです。美しさよりも安全性が何より重要です。&lt;/p&gt;

&lt;h2 id=&#34;補足2-constructor-injection-vs-setter-injection:d011759973daaf90efe485c60339885a&#34;&gt;補足2: Constructor Injection vs Setter Injection&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.1000k.net/2012/10/23/%e6%8a%84%e8%a8%b3-constructor-injection-vs-setter-injection/&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://blog.1000k.net/2012/10/23/%e6%8a%84%e8%a8%b3-constructor-injection-vs-setter-injection/&#39;, &#39;抄訳: Constructor Injection vs. Setter Injection | 1000g&#39;]);&#34; &gt;抄訳: Constructor Injection vs. Setter Injection | 1000g&lt;/a&gt; にて、コンストラクター・インジェクションとセッター・インジェクションのどちらが良いかを考察しています。結論としてはコンストラクター・インジェクションがベターです。&lt;/p&gt;

&lt;h2 id=&#34;参考:d011759973daaf90efe485c60339885a&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ja.wikipedia.org/wiki/%E4%BE%9D%E5%AD%98%E6%80%A7%E3%81%AE%E6%B3%A8%E5%85%A5&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://ja.wikipedia.org/wiki/%E4%BE%9D%E5%AD%98%E6%80%A7%E3%81%AE%E6%B3%A8%E5%85%A5&#39;, &#39;依存性の注入 &amp;#8211; Wikipedia&#39;]);&#34; &gt;依存性の注入 &amp;#8211; Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/m-hiyama/20060926/1159253903&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://d.hatena.ne.jp/m-hiyama/20060926/1159253903&#39;, &#39;DI（依存性注入）を白紙から説明してみる &amp;#8211; 檜山正幸のキマイラ飼育記&#39;]);&#34; &gt;DI（依存性注入）を白紙から説明してみる &amp;#8211; 檜山正幸のキマイラ飼育記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://martinfowler.com/articles/injection.html&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://martinfowler.com/articles/injection.html&#39;, &#39;Inversion of Control Containers and the Dependency Injection pattern&#39;]);&#34; &gt;Inversion of Control Containers and the Dependency Injection pattern&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;リファクタリング界の大御所、Martin Fowler氏の考察。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.techscore.com/tech/Java/Others/Spring/1-3/&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://www.techscore.com/tech/Java/Others/Spring/1-3/&#39;, &#39;Dependency Injection のタイプ | TECHSCORE(テックスコア)&#39;]);&#34; &gt;Dependency Injection のタイプ | TECHSCORE(テックスコア)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.phpunit.de/manual/3.7/ja/test-doubles.html#test-doubles.mock-objects&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://www.phpunit.de/manual/3.7/ja/test-doubles.html#test-doubles.mock-objects&#39;, &#39;第10章 テストダブル&#39;]);&#34; &gt;第10章 テストダブル&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;PHPUnit 公式マニュアルによるモックの使い方。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>抄訳: Constructor Injection vs. Setter Injection</title>
      <link>http://1000k.github.io/2012/10/23/translation-constructor-injection-vs-setter-injection/</link>
      <pubDate>Tue, 23 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>http://1000k.github.io/2012/10/23/translation-constructor-injection-vs-setter-injection/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://misko.hevery.com/2009/02/19/constructor-injection-vs-setter-injection/&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://misko.hevery.com/2009/02/19/constructor-injection-vs-setter-injection/&#39;, &#39;Constructor Injection vs. Setter Injection&#39;]);&#34; &gt;Constructor Injection vs. Setter Injection&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3年前の記事ですが、かなり役立つ知識だったので、一部補足しながら訳しました。コードを単体テスト可能にする（＝「接合点を作る」）ために知っておくべき内容です。&lt;/p&gt;

&lt;p&gt;クラスBに依存しているクラスAをテストするときに、依存性を排除する典型的な方法として &lt;strong&gt;Constructor Injection&lt;/strong&gt; (コンストラクター・インジェクション) と &lt;strong&gt;Setter Injection&lt;/strong&gt; (セッター・インジェクション) があります。以下でそれぞれのやり方と、どちらがベターかを解説します。&lt;/p&gt;

&lt;h2 id=&#34;setter-injection-とは:b2ac201c3b760f5a9180de0cd4a738c1&#34;&gt;Setter Injection とは？&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Springフレームワークで使用。&lt;/li&gt;
&lt;li&gt;コンストラクタは引数を取らない。&lt;/li&gt;
&lt;li&gt;インスタンス化後、そのインスタンスの setter メソッドを使ってオブジェクトを注入する。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;Database db = new Database();

OfflineQueue queue = new OfflineQueue();
queue.setDatabase(db);

CreditCardProcessor processor = new CreditCardProcessor();
processor.setOfflineQueue(queue);
processor.setDatabase(db);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;constructor-injection-とは:b2ac201c3b760f5a9180de0cd4a738c1&#34;&gt;Constructor Injection とは？&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Pico-Container や GUICE で使用。&lt;/li&gt;
&lt;li&gt;コンストラクタの引数にインスタンスを渡し、メンバ変数に設定する方法。&lt;/li&gt;
&lt;li&gt;もし引数が渡されなかったらデフォルトのインスタンスを作成する。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;CreditCardProcessor processor = new CreditCardProcessor(?queue?, ?db?);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;どちらが良いか:b2ac201c3b760f5a9180de0cd4a738c1&#34;&gt;どちらが良いか？&lt;/h2&gt;

&lt;p&gt;一見すると、コンストラクタにごちゃごちゃ引数を渡さなくて済むぶん Setter Injection の方が楽に書けて良いように思えます。しかし Contructor Injection の方が優れている部分があるため、私は後者を選びます。それは、Constructor Injection はパラメータの順序を指定でき、&lt;a href=&#34;http://misko.hevery.com/2008/08/01/circular-dependency-in-constructors-and-dependency-injection/&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://misko.hevery.com/2008/08/01/circular-dependency-in-constructors-and-dependency-injection/&#39;, &#39;Circular Dependency&#39;]);&#34; title=&#34;Circular Dependency in constructors and Dependency Injection&#34;&gt;Circular Dependency&lt;/a&gt;（循環参照）に陥る危険が無いという点です。&lt;/p&gt;

&lt;p&gt;一般的なアプリは多くのクラスと連携します。そこに Setter Injection を採用すると、何度も setter の呼び出しを行う事になってしまいます。これだと連携するクラスの数が増えるたびに setter をコールする行を追加しなくてはいけません。面倒ですし、コールし忘れの危険性も増えます。さらに set する順番が決まっている場合は最悪です。&lt;/p&gt;

&lt;p&gt;一方で Constructor Injection はコンストラクタさえ書いてしまえば、指定した順に、自動でクラスをインスタンス化してくれます。コンストラクトの時点ですべて設定が完了するので、後はそのオブジェクトを確実に使えます。&lt;/p&gt;

&lt;h2 id=&#34;例:b2ac201c3b760f5a9180de0cd4a738c1&#34;&gt;例&lt;/h2&gt;

&lt;p&gt;CreaditCardProcessor クラスをインスタンス化するケースを考えてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CreditCardProcessor processor = new CreditCardProcessor();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;インスタンス化できてめでたしめでたし、とはなりません。実際にはこのクラスは OfflineQueue クラスと連携し、またDBとやりとりするために Database クラスとも連携します。これらのインスタンスを set してやらなければ使えません。&lt;/p&gt;

&lt;p&gt;これらすべてを Setter Injection で行うと下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Database クラスのインスタンス化
Database db = new Database();

// 必要なインスタンスを setter で設定する
db.setUsername(&amp;quot;username&amp;quot;);
db.setPassword(&amp;quot;password&amp;quot;);
db.setUrl(&amp;quot;jdbc:....&amp;quot;);

// OfflineQueue クラスのインスタンス化
OfflineQueue queue = new OfflineQueue();

// setter による設定
queue.setDatabase(db);

// CreditCardProcessor クラスに、上で作ったインスタンスを setter でセットする
CreditCardProcessor processor = new CreditCardProcessor();
processor.setOfflineQueue(queue);
processor.setDatabase(db);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで全部？いや、要件が増えればさらに setter でセットする内容は増えるかもしれません。何かフレームワークを使っていれば楽に書く方法があるかもしれませんが、使ってない場合はもうお手上げです。&lt;/p&gt;

&lt;p&gt;では同じことを Constructor Injection で実現してみましょう。CreditCardProcessor は以下のようにインスタンス化できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CreditCardProcessor processor = new CreditCardProcessor(?queue?, ?db?);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンストラクタは OfflineQueue と Database のインスタンスを必要とするので、両方ともインスタンス化しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 必要となるインスタンスを作成する
Database db = new Database(&amp;quot;username&amp;quot;, &amp;quot;password&amp;quot;, &amp;quot;jdbc:....&amp;quot;);
OfflineQueue queue = new OfflineQueue(db);

// コンストラクタに渡してやる
CreditCardProcessor processor = new CreditCardProcessor(queue, db);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンストラクタにインスタンスを渡すことができました。これで完了です。&lt;/p&gt;

&lt;p&gt;このコードの良いところは、コンストラクタに渡す引数が不足していたらコンパイルエラーがちゃんと出ることです。また、意図していない順番でインスタンス化される不具合も防げます。&lt;/p&gt;

&lt;p&gt;というわけで、個人的には Constructor Injection がおすすめです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>header()関数を使ったメソッドをPHPUnitでテストする方法</title>
      <link>http://1000k.github.io/2012/10/20/how-to-test-method-using-header-function-in-phpunit/</link>
      <pubDate>Sat, 20 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>http://1000k.github.io/2012/10/20/how-to-test-method-using-header-function-in-phpunit/</guid>
      <description>

&lt;p&gt;PHPUnit はテスト中のメッセージを逐一標準出力するため、header() 関数を用いたメソッドのテストができません。&lt;/p&gt;

&lt;p&gt;header() 関数はその実行前の何らかの標準出力がされていると「Cannot modify header information」というエラーを吐いてしまいます。&lt;/p&gt;

&lt;p&gt;以下、テストコードと対策をメモします。&lt;/p&gt;

&lt;h2 id=&#34;現象:caf62378c2e0b948501f395df88dace1&#34;&gt;現象&lt;/h2&gt;

&lt;p&gt;たとえば下記のようなテストケースはエラーで止まります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Api {
    public function output($data, $response_code = 200) {
        http_response_code($response_code);
        header(&#39;Content-Type: application/json&#39;); // PHPUnitの標準出力のせいで、テストケース中にエラーになる
        $output = json_encode($data);

        echo $output;
        return $output;
    }
}

class ApiTest extends \PHPUnit_Framework_TestCase {
    // テストケース
    /**
     * @covers Api::output
     * @dataProvider forTestOutput
     */
    public function testOutput($data, $response_code) {
        ob_start();
        $actual = $this-&amp;gt;object-&amp;gt;output($data, $response_code);
        $output = ob_get_contents();
        $expected = json_encode($data);

        $this-&amp;gt;assertEquals($expected, $actual);
        $this-&amp;gt;assertEquals($output, $actual);
        $this-&amp;gt;assertEquals(http_response_code(), $response_code);
        ob_clean();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のようなエラーを吐きます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cannot modify header information - headers already sent by (output started at D:\xampp\php\pear\PHPUnit\Util\Printer.php:172)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;対策:caf62378c2e0b948501f395df88dace1&#34;&gt;対策&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;@runInSeparateProcess&lt;/strong&gt; アノテーションを利用することで、テストケースだけを別プロセスで実行することができます。&lt;/p&gt;

&lt;p&gt;つまり、標準出力が真っさらな状態でテストを開始できるので、header() 関数がエラーを吐きません。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
     * @covers Api::output
     * @dataProvider forTestOutput
     * @runInSeparateProcess
     */
    public function testOutput($data, $response_code) {
        // ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;PHPUnit 3.7.8 by Sebastian Bergmann.

.

Time: 3 seconds, Memory: 2.75Mb

OK (1 test, 3 assertions)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;header() 関数を使ったメソッドのテストをする際には覚えておきたいテクニックです。&lt;/p&gt;

&lt;h2 id=&#34;参考:caf62378c2e0b948501f395df88dace1&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.phpunit.de/manual/3.7/ja/appendixes.annotations.html#appendixes.annotations.runInSeparateProcess&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://www.phpunit.de/manual/3.7/ja/appendixes.annotations.html#appendixes.annotations.runInSeparateProcess&#39;, &#39;付録B アノテーション&#39;]);&#34; &gt;付録B アノテーション&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.php.net/manual/ja/function.header.php&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://www.php.net/manual/ja/function.header.php&#39;, &#39;PHP: header &amp;#8211; Manual&#39;]);&#34; &gt;PHP: header &amp;#8211; Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/9745080/test-php-headers-with-phpunit&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://stackoverflow.com/questions/9745080/test-php-headers-with-phpunit&#39;, &#39;unit testing &amp;#8211; Test PHP headers with PHPunit &amp;#8211; Stack Overflow&#39;]);&#34; &gt;unit testing &amp;#8211; Test PHP headers with PHPunit &amp;#8211; Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>PHPUnitをアップグレードしたら動作しなくなった</title>
      <link>http://1000k.github.io/2012/10/19/phpunit-does-not-run-after-upgrade/</link>
      <pubDate>Fri, 19 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>http://1000k.github.io/2012/10/19/phpunit-does-not-run-after-upgrade/</guid>
      <description>

&lt;p&gt;PHPUnit を何となくアップグレードしたら動かなくなってしまいました。&lt;/p&gt;

&lt;p&gt;今回は pear upgrade で PHPUnit を 3.6.11 から 3.6.12 に 更新した後、phpunit コマンドを叩くと下記のようなエラーが出るようになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# phpunit

Parse error: syntax error, unexpected T_FUNCTION, expecting &#39;)&#39; in /usr/local/lib/php/PHP/Timer/Autoload.php on line 47

Call Stack:
    0.0018      50328   1. {main}() /usr/local/bin/phpunit:0
    0.0030      87992   2. require(&#39;/usr/local/lib/php/PHPUnit/Autoload.php&#39;) /usr/local/bin/phpunit:43
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修復に小一時間かかったので、直し方をメモしておきます。&lt;/p&gt;

&lt;h2 id=&#34;原因:50be0dd242e143a3defa66c95863f49e&#34;&gt;原因&lt;/h2&gt;

&lt;p&gt;PHPUnit は PHP &amp;gt;= 5.3 での利用を強く推奨しており、PHP &amp;lt;= 5.2 のままだと動かない機能を盛り込んでくることがあります。&lt;/p&gt;

&lt;p&gt;また、本体以外にも多数の依存パッケージがあり、どれかが急に &amp;gt;= 5.3 の機能を使い始めても動かなくなります。&lt;/p&gt;

&lt;p&gt;私の環境は PHP 5.2.x だったため、今回のエラーに出くわしました。原因は phpunit/PHP_Timer がバージョンアップしたせいでした。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/sebastianbergmann/php-timer/blob/1.0.4/PHP/Timer/Autoload.php&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;https://github.com/sebastianbergmann/php-timer/blob/1.0.4/PHP/Timer/Autoload.php&#39;, &#39;phpunit/PHP_Timer-1.0.4&#39;]);&#34; title=&#34;php-timer/PHP/Timer/Autoload.php at 1.0.4 · sebastianbergmann/php-timer&#34;&gt;phpunit/PHP_Timer-1.0.4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/sebastianbergmann/php-timer/blob/1.0.3/PHP/Timer/Autoload.php&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;https://github.com/sebastianbergmann/php-timer/blob/1.0.3/PHP/Timer/Autoload.php&#39;, &#39;phpunit/PHP_Timer-1.0.3&#39;]);&#34; title=&#34;php-timer/PHP/Timer/Autoload.php at 1.0.3 · sebastianbergmann/php-timer&#34;&gt;phpunit/PHP_Timer-1.0.3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上記のソースからおわかりのように、1.0.4 から匿名関数を使っています。これは PHP &amp;gt;= 5.3 でしか動きません。5.2系ではパースエラーになります。&lt;/p&gt;

&lt;h2 id=&#34;対策:50be0dd242e143a3defa66c95863f49e&#34;&gt;対策&lt;/h2&gt;

&lt;p&gt;PHP_Timer を再インストールすることで修正可能です。&lt;/p&gt;

&lt;p&gt;アンインストールの時は依存関係を無視して削除するため「-n」オプションを付けています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# pear uninstall -n phpunit/PHP_Timer
&amp;quot;phpunit/PHP_Timer&amp;quot; can be optionally used by installed package pear/PHP_CodeSniffer
warning: phpunit/PHP_Timer (version &amp;gt;= 1.0.2) is required by installed package &amp;quot;phpunit/phpcpd&amp;quot;
warning: phpunit/PHP_Timer (version &amp;gt;= 1.0.1, version &amp;amp;lt;= 1.0.3) is required by installed package &amp;quot;phpunit/PHPUnit&amp;quot;
warning: phpunit/PHP_Timer should not be uninstalled, other installed packages depend on this package
uninstall ok: channel://pear.phpunit.de/PHP_Timer-1.0.4

#  pear install phpunit/PHP_Timer-1.0.3
downloading PHP_Timer-1.0.3.tgz ...
Starting to download PHP_Timer-1.0.3.tgz (3,743 bytes)
....done: 3,743 bytes
install ok: channel://pear.phpunit.de/PHP_Timer-1.0.3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上で動作するようになりました。&lt;/p&gt;

&lt;p&gt;PHP 5.2系の人はうかつに 「pear upgrade phpunit/phpunit」なんてコマンドを叩かないようにしましょう。&lt;/p&gt;

&lt;p&gt;もしくはさっさと5.4系に移行しましょう。&lt;/p&gt;

&lt;h2 id=&#34;参考:50be0dd242e143a3defa66c95863f49e&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://dustyreagan.com/downgrade-phpunit-3-6-to-3-5-15/&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://dustyreagan.com/downgrade-phpunit-3-6-to-3-5-15/&#39;, &#39;How to Downgrade PHPUnit 3.6 to 3.5.15 | Dusty Reagan&#39;]);&#34; &gt;How to Downgrade PHPUnit 3.6 to 3.5.15 | Dusty Reagan&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;pear パッケージのダウングレード方法はこちらを参考にしました。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>vfsStreamをインストールする</title>
      <link>http://1000k.github.io/2012/09/04/installing-vfsstream/</link>
      <pubDate>Tue, 04 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>http://1000k.github.io/2012/09/04/installing-vfsstream/</guid>
      <description>

&lt;p&gt;PHPUnit のマニュアルに出てくる仮想ファイルシステムの vfsStream ですが、&lt;a href=&#34;http://www.phpunit.de/manual/3.6/ja/test-doubles.html#test-doubles.mocking-the-filesystem&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://www.phpunit.de/manual/3.6/ja/test-doubles.html#test-doubles.mocking-the-filesystem&#39;, &#39;公式マニュアル&#39;]);&#34; title=&#34;第10章 テストダブル&#34;&gt;公式マニュアル&lt;/a&gt;に載っている方法では既にPEARチャンネルが消えているため、インストールできません。&lt;/p&gt;

&lt;p&gt;以下に正しいインストール方法をメモしておきます。&lt;/p&gt;

&lt;h2 id=&#34;php-5-2-の場合:95f81ffdb8fe1ed455aec73bf72b588a&#34;&gt;PHP &amp;lt; 5.2 の場合&lt;/h2&gt;

&lt;p&gt;以下のコマンドで vfsStream &amp;lt; 1.0 をインストールできます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pear channel-discover pear.bovigo.org
$ pear install bovigo/vfsStream-beta

downloading vfsStream-0.12.0.tgz ...
Starting to download vfsStream-0.12.0.tgz (459,376 bytes)
.........done: 459,376 bytes
install ok: channel://pear.bovigo.org/vfsStream-0.12.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;php-5-3-の場合:95f81ffdb8fe1ed455aec73bf72b588a&#34;&gt;PHP &amp;gt;= 5.3 の場合&lt;/h2&gt;

&lt;p&gt;vfsStream &amp;gt;= 1.0 を &lt;a href=&#34;http://getcomposer.org/&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://getcomposer.org/&#39;, &#39;Composer&#39;]);&#34; &gt;Composer&lt;/a&gt; でインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;mikey179/vfsStream&amp;quot;: &amp;quot;v1.1.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用可能なバージョンは &lt;a href=&#34;https://packagist.org/packages/mikey179/vfsStream&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;https://packagist.org/packages/mikey179/vfsStream&#39;, &#39;mikey179/vfsStream &amp;#8211; Packagist&#39;]);&#34; &gt;mikey179/vfsStream &amp;#8211; Packagist&lt;/a&gt; を参照。&lt;/p&gt;

&lt;h2 id=&#34;参考:95f81ffdb8fe1ed455aec73bf72b588a&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mikey179/vfsStream/wiki/Install&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;https://github.com/mikey179/vfsStream/wiki/Install&#39;, &#39;Download and install vfsStream · mikey179/vfsStream Wiki&#39;]);&#34; title=&#34;Download and install vfsStream · mikey179/vfsStream Wiki&#34;&gt;Download and install vfsStream · mikey179/vfsStream Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Phactoryで単数形のテーブルをテストする</title>
      <link>http://1000k.github.io/2012/05/30/how-to-test-singular-named-table-by-phacory/</link>
      <pubDate>Wed, 30 May 2012 00:00:00 +0000</pubDate>
      
      <guid>http://1000k.github.io/2012/05/30/how-to-test-singular-named-table-by-phacory/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://phactory.org/&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://phactory.org/&#39;, &#39;Phactory&#39;]);&#34; title=&#34;Phactory - A Database Factory for PHP Unit Tests&#34;&gt;Phactory&lt;/a&gt;はRoRライクな設計思想のため、テーブル名を勝手に複数形に変換（pluralize）します。&lt;/p&gt;

&lt;p&gt;このせいで単数形のテーブル名がテストできない場合、下記のようにdefine()の前に&lt;strong&gt;setInflector()&lt;/strong&gt;を使えば直ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// dtb_shopというテーブルをテストしたい
    protected function setUp() {
        $pdo = new PDO(DB_TYPE . &#39;:dbname=&#39; . DB_NAME . &#39;;host=&#39; . DB_SERVER . &#39;;port=&#39; . DB_PORT, DB_USER, DB_PASSWORD);
        $pdo-&amp;gt;exec(&#39;CREATE TABLE dtb_shop (shop_id INTEGER, shop_key TEXT)&#39;);

        Phactory::setConnection($pdo);
        Phactory::reset();
        Phactory::setInflection(&#39;dtb_shop&#39;, &#39;dtb_shop&#39;);    // 勝手に「dtb_shops」にされるのを防ぐ
        Phactory::define(&#39;dtb_shop&#39;, array(&#39;shop_id&#39; =&amp;gt; &#39;$n&#39;, &#39;shop_key&#39; =&amp;gt; &#39;test shop $n&#39;));

        $this-&amp;gt;object = new ShopModel;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考: &lt;a href=&#34;https://github.com/chriskite/phactory/issues/3&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;https://github.com/chriskite/phactory/issues/3&#39;, &#39;Issue #3: Can&amp;#8217;t create singular tables · chriskite/phactory · GitHub&#39;]);&#34; title=&#34;Issue #3: Can&#39;t create singular tables · chriskite/phactory · GitHub&#34;&gt;Issue #3: Can&amp;#8217;t create singular tables · chriskite/phactory · GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>スタブとモック</title>
      <link>http://1000k.github.io/2011/04/07/what-is-stub-and-mock/</link>
      <pubDate>Thu, 07 Apr 2011 00:00:00 +0000</pubDate>
      
      <guid>http://1000k.github.io/2011/04/07/what-is-stub-and-mock/</guid>
      <description>

&lt;p&gt;今までモックをほとんど使ったことがなかったので、勉強してみました。&lt;/p&gt;

&lt;h2 id=&#34;スタブとは:64967b015e52257cb9a199be0513508e&#34;&gt;スタブとは&lt;/h2&gt;

&lt;p&gt;ref: &lt;a href=&#34;http://ja.wikipedia.org/wiki/%E3%82%B9%E3%82%BF%E3%83%96&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://ja.wikipedia.org/wiki/%E3%82%B9%E3%82%BF%E3%83%96&#39;, &#39;スタブ &amp;#8211; Wikipedia&#39;]);&#34; title=&#34;スタブ - Wikipedia&#34;&gt;スタブ &amp;#8211; Wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;呼び出す側（上位）のモジュールを検査する場合に、呼び出される側（下位）の部品モジュールが未完成であることがある。このとき、呼び出される側の部品モジュールの代用とする仮のモジュールを、「スタブ」と呼ぶ。スタブモジュールは設計仕様に定義されている全ての関数を実装してあるが、関数内部は正規の動作をする事無く適当な定数を返すというような作りになっている事が多い。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;「必ずfalseを返すスタブ」「ランダムな整数を返すスタブ」なんて言葉はよく聞きます。&lt;/p&gt;

&lt;h2 id=&#34;モックとは:64967b015e52257cb9a199be0513508e&#34;&gt;モックとは&lt;/h2&gt;

&lt;p&gt;ref: &lt;a href=&#34;http://d.hatena.ne.jp/sekom/20090702/p1&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://d.hatena.ne.jp/sekom/20090702/p1&#39;, &#39;スタブとモックの違い &amp;#8211; ソフト開発お仕事メモ&#39;]);&#34; title=&#34;スタブとモックの違い - ソフト開発お仕事メモ&#34;&gt;スタブとモックの違い &amp;#8211; ソフト開発お仕事メモ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;モック戦略を使用する際には、3つの手順を踏むことになります。&lt;/p&gt;

&lt;p&gt;| No | 手順名                  | 説明                                                                           |
| &amp;ndash; | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- |
| 1  | 期待値の設定               | モックオブジェクトに対して、メソッドが呼び出されるべき順序を記録します。その際に、期待される引数、モックオブジェクトのメソッドが返す戻り値も設定します。 |
| 2  | テスト条件下でのモックオブジェクトの使用 | モックオブジェクトを使用したテストを実施します。                                                     |
| 3  | 結果の検証                | モックオブジェクトに対し、期待されたとおりにモックオブジェクトが使用されたか問い合わせます。                               |&lt;/p&gt;

&lt;h2 id=&#34;スタブやモックが必要になる理由:64967b015e52257cb9a199be0513508e&#34;&gt;スタブやモックが必要になる理由&lt;/h2&gt;

&lt;p&gt;ref: &lt;a href=&#34;http://www39.atwiki.jp/startruby/pages/23.html&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://www39.atwiki.jp/startruby/pages/23.html&#39;, &#39;Start! Ruby &amp;#8211; RSpecの構文&#39;]);&#34; title=&#34;Start! Ruby - RSpecの構文&#34;&gt;Start! Ruby &amp;#8211; RSpecの構文&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;全てを「本物」でテストしようとすると、「全てが揃わないとテストできない」という本末転倒な事が起こりかねない。&lt;/li&gt;
&lt;li&gt;たとえば時刻に関するオブジェクトのように、システムの構成によって変化してしまうオブジェクトがあると、テスト環境によって差異ができてしまう。&lt;/li&gt;
&lt;li&gt;UnitTestが大きな問題に移ると段々と結合テスト化してしまう、という問題がある。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;※ ただし、スタブ/モックを多用し過ぎると、今度はインタフェース不一致の発見を先送りにする、という状況にもなりかねない。このあたりはさじ加減が必要。&lt;/p&gt;

&lt;h2 id=&#34;モックでできること:64967b015e52257cb9a199be0513508e&#34;&gt;モックでできること&lt;/h2&gt;

&lt;p&gt;ref: &lt;a href=&#34;http://gihyo.jp/dev/feature/01/php-test/0004&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://gihyo.jp/dev/feature/01/php-test/0004&#39;, &#39;PHPUnit3で始めるユニットテスト：第4回　モックオブジェクトを使ったテスト｜gihyo.jp … 技術評論社&#39;]);&#34; title=&#34;PHPUnit3で始めるユニットテスト：第4回　モックオブジェクトを使ったテスト｜gihyo.jp … 技術評論社&#34;&gt;PHPUnit3で始めるユニットテスト：第4回　モックオブジェクトを使ったテスト｜gihyo.jp … 技術評論社&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;生成されるオブジェクトにメソッドを定義する&lt;/li&gt;
&lt;li&gt;そのメソッドの振る舞いを指定する

&lt;ul&gt;
&lt;li&gt;実行回数の制約を設ける

&lt;ul&gt;
&lt;li&gt;たとえば「1回のみ呼び出される」や「0回以上呼び出される」&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;メソッド名を指定する&lt;/li&gt;
&lt;li&gt;具体的な振る舞いを記述する

&lt;ul&gt;
&lt;li&gt;メソッドの戻り値&lt;/li&gt;
&lt;li&gt;メソッドが投げる例外&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;スタブとモックの違い:64967b015e52257cb9a199be0513508e&#34;&gt;スタブとモックの違い&lt;/h2&gt;

&lt;p&gt;ref: &lt;a href=&#34;http://www.ibm.com/developerworks/jp/web/library/wa-mockrails/index.html&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://www.ibm.com/developerworks/jp/web/library/wa-mockrails/index.html&#39;, &#39;Ruby on Rails でのモックとスタブの作成&#39;]);&#34; title=&#34;Ruby on Rails でのモックとスタブの作成&#34;&gt;Ruby on Rails でのモックとスタブの作成&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;「&lt;a href=&#34;http://d.hatena.ne.jp/devbankh/20100210&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://d.hatena.ne.jp/devbankh/20100210&#39;, &#39;モックとスタブの違い &amp;#8211; [lib]&#39;]);&#34; title=&#34;モックとスタブの違い - [lib]&#34;&gt;モックとスタブの違い &amp;#8211; [lib]&lt;/a&gt;」&lt;/p&gt;

&lt;p&gt;モック・オブジェクトは一種のスタブです。モック・オブジェクトは、テスト対象のオブジェクトを使用するクライアント・コードを置き換えます。しかしモック・オブジェクトはそれ以上のことを行い、テスト対象のオブジェクトがクライアント・コードを実際にどう使うかを測定するのです。&lt;/p&gt;

&lt;p&gt;インターフェースの使い方をテストする場合にはモックを、インターフェースの使い方をまったく気にしない場合にはスタブを使う必要があります。&lt;/p&gt;

&lt;p&gt;モック・オブジェクトの作成は、スタブの作成とよく似ています。違いは、スタブは受動的であるということです。スタブは、スタブの作成対象のメソッドに対して呼び出しを行う実在のソリューションを単にシミュレーションするにすぎません。一方モックは能動的であり、モック・オブジェクトを使って行うその方法を実際にテストします。想定の動作と一致する方法でモックを使わないと、テストは失敗します。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ref: &lt;a href=&#34;http://capsctrl.que.jp/kdmsnr/wiki/bliki/?TestDouble&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://capsctrl.que.jp/kdmsnr/wiki/bliki/?TestDouble&#39;, &#39;Martin Fowler&amp;#8217;s Bliki in Japanese &amp;#8211; テストダブル&#39;]);&#34; title=&#34;Martin Fowler&#39;s Bliki in Japanese - テストダブル&#34;&gt;Martin Fowler&amp;#8217;s Bliki in Japanese &amp;#8211; テストダブル&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;スタブは、テスト時の呼び出しに対して、あらかじめ用意された結果を返す。通常、テスト用にプログラムされたところ以外には応答しない。スタブは呼び出しの情報を記録することもある。例えば、Eメールゲートウェイスタブは「送られた」メッセージを記録するような場合だ。単に「送られた」メールの数を記録する場合もあるだろう。&lt;/p&gt;

&lt;p&gt;モックは、エクスペクテーションが事前にプログラムされたものである。エクスペクテーションとは、受信する一連の呼び出しの仕様を表わしたものである。期待されない呼び出しが行なわれた場合は例外をスローする。また、テスト実行後の検証(verification)で、期待された呼び出しがすべてきちんと行われたかどうかを確認する。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>CakePHP のコントローラを単純化するために例外を使う</title>
      <link>http://1000k.github.io/2010/07/23/simplify-controller-by-exception/</link>
      <pubDate>Fri, 23 Jul 2010 00:00:00 +0000</pubDate>
      
      <guid>http://1000k.github.io/2010/07/23/simplify-controller-by-exception/</guid>
      <description>&lt;p&gt;2009年6月12日の記事でだいぶ古いのですが、CakePHP のコードを改善する TIPS があったので訳してみました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mark-story.com/posts/view/simplifying-controller-logic-with-exceptions&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://mark-story.com/posts/view/simplifying-controller-logic-with-exceptions&#39;, &#39;Simplifying Controller logic with Exceptions | Mark Story&#39;]);&#34; title=&#34;Simplifying Controller logic with Exceptions | Mark Story&#34;&gt;Simplifying Controller logic with Exceptions | Mark Story&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;要約すると、&lt;strong&gt;「モデル内で例外を吐くようにすると、エラーコードが読みやすくなり、コントローラのテストもしやすくなるよ」&lt;/strong&gt;ということです。&lt;/p&gt;

&lt;p&gt;以下、訳です。&lt;/p&gt;

&lt;p&gt;増大するコードと格闘する日々・・・どうにかクリエイティブな方法で解決したい。そんな悩みを、モデルのメソッドから例外を投げる方法で解決しました。別にビックリするようなものではないです。ただfalseを返すより、ちょっと便利な点がいくつかあります。&lt;/p&gt;

&lt;p&gt;第一に、if-elseを減らすことができます。第二に、エラーが起こる部分のソースにエラーメッセージを書くことができるので、何度も使うメソッドならエラーメッセージを重複させずに書くことができます。&lt;/p&gt;

&lt;p&gt;例えば以下のメソッドは、リモートアドレスからリソースをダウンロードし、&lt;/p&gt;

&lt;p&gt;ローカルファイルシステムとデータベースに記録するものです。&lt;em&gt;（訳注: ダウンロードの時点で失敗すると例外を、保存に成功するとtrueを、保存に失敗するとfalseを返します。）&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function downloadResource($url, $userId, $type = &#39;image&#39;) {
    if (!isset($this-&amp;gt;_fetchMimes[$type])) {
        throw new OutOfBoundsException(__(&#39;Invalid media type&#39;, true));
    }
    $this-&amp;gt;_loadSocket($url);
    $resource = $this-&amp;gt;Socket-&amp;gt;get($url);
    if (!isset($this-&amp;gt;Socket-&amp;gt;response[&#39;header&#39;][&#39;Content-Type&#39;])) {
        throw new OutOfBoundsException(__(&#39;Submitted url has no Mime-Type&#39;, true));
    }
    $allowedContentTypes = $this-&amp;gt;_fetchMimes[$type];
    if (!in_array($this-&amp;gt;Socket-&amp;gt;response[&#39;header&#39;][&#39;Content-Type&#39;], $allowedContentTypes)) {
        throw new OutOfBoundsException(__(&#39;Submitted url has an invalid Mime-Type&#39;, true));
    }
    $newFile = array(
        &#39;File&#39; =&amp;gt; array(
            &#39;file&#39; =&amp;gt; $this-&amp;gt;_saveFetchedFile($resource, $url, $this-&amp;gt;Socket-&amp;gt;response[&#39;header&#39;][&#39;Content-Type&#39;]),
            &#39;user_id&#39; =&amp;gt; $userId,
            &#39;title&#39; =&amp;gt; $url,
        )
    );
    $this-&amp;gt;create($newMedia);
    if ($this-&amp;gt;save()) {
        return true;
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;見てわかる通り、起きてはならないことが起きた時には OutOfBoundsExceptions を投げています。最近のバージョンの PHP に含まれている SPL ライブラリには、便利なクラスが多数用意されています。もちろん自分で例外を作ることもできますが、たいていは組み込みの例外を使うだけで十分でしょう。&lt;/p&gt;

&lt;p&gt;これを使えば、コントローラのメソッドをかなりスッキリさせることができます。何重もの if でチェックする必要が無くなります。また、シンプルでエラーの見通しも良いコードを書くことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try {
    $this-&amp;gt;File-&amp;gt;downloadResource($this-&amp;gt;data[&#39;File&#39;][&#39;url&#39;], $this-&amp;gt;Auth-&amp;gt;user(&#39;id&#39;), &#39;image&#39;);
    //do some additional file handling and data processing.

    $this-&amp;gt;Session-&amp;gt;setFlash(__(&#39;File uploaded successfully&#39;, true));
} catch(OutOfBoundsException $e) {
    $this-&amp;gt;Session-&amp;gt;setFlash($e-&amp;gt;getMessage());
}
$this-&amp;gt;redirect(array(&#39;action&#39; =&amp;gt; &#39;index&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このメソッドの例外発生をテストするのは簡単です。assertFalse を使うのではなく、pass() と fail() を使えばいいのです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// (訳注) 不正なURLを送った時に例外が発生することをテストする
try {
    $this-&amp;gt;File-&amp;gt;downloadResource(&#39;http:/bogus.com/&#39;, 1, &#39;image&#39;);  // 間違ったURL
    $this-&amp;gt;fail(&#39;No exception thrown with bogus arguments&#39;);
} catch (Exception $e) {
    $this-&amp;gt;pass(&#39;Exception thrown&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例外を使うと便利になることは多いです。だからと言って、false を返すタイプのメソッドすべてを例外を返すようにする必要はないでしょう。たとえばヘルパから例外を返すようにすると、満足より苦痛を感じることのほうが多くなるでしょう。&lt;/p&gt;

&lt;p&gt;どんなツールもそうですが、正しく使えばメンテナンス性の良いコードを生み出すことができるのです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Selenium IDE &#43; Pearl Crescent Page Saver で複数画面のキャプチャを自動化する</title>
      <link>http://1000k.github.io/2010/06/11/automate-screen-capture-using-selenium-ide-pearl-crescent-page-saver/</link>
      <pubDate>Fri, 11 Jun 2010 00:00:00 +0000</pubDate>
      
      <guid>http://1000k.github.io/2010/06/11/automate-screen-capture-using-selenium-ide-pearl-crescent-page-saver/</guid>
      <description>

&lt;p&gt;多くの画面があるサイトで、すべてのページを、スクロール領域すべてを含めてキャプチャしなければならない。&lt;/p&gt;

&lt;p&gt;こんなこと手動でやっていては大変です。しかも画面修正が入って「もう一回全部撮り直せ」と言われたらもう死ぬしかないですね。&lt;/p&gt;

&lt;p&gt;早まる前に、この記事のやり方で自動化してください。&lt;/p&gt;

&lt;h2 id=&#34;必要なもの:462da812d7d4ed2797cfbcdf095e949a&#34;&gt;必要なもの&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;FireFox 3.x&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://seleniumhq.org/download/&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://seleniumhq.org/download/&#39;, &#39;Selenium IDE&#39;]);&#34; title=&#34;Selenium IDE&#34;&gt;Selenium IDE&lt;/a&gt; (執筆時 バージョン1.0.7)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pearlcrescent.com/products/pagesaver/&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://pearlcrescent.com/products/pagesaver/&#39;, &#39;Pearl Crescent Page Saver&#39;]);&#34; title=&#34;Pearl Crescent Page Saver&#34;&gt;Pearl Crescent Page Saver&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;手順:462da812d7d4ed2797cfbcdf095e949a&#34;&gt;手順&lt;/h2&gt;

&lt;p&gt;まず、Pearl Crescent Page Saver のショートカット設定をします。「Page Saverオプション」から、下記の通り設定します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;「全般」タブ

&lt;ul&gt;
&lt;li&gt;「キーボードショートカットかツールバーのボタンがクリックされた時:」 &amp;#8211; &lt;strong&gt;ページ全体&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;「キーボードショートカット:」 &amp;#8211; &lt;strong&gt;Alt+w&lt;/strong&gt; (好きなキーで構わないですが、下記はこの設定でやります)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;「画像のキャプチャー」タブ

&lt;ul&gt;
&lt;li&gt;「ファイルの保存名:」 &amp;#8211; &lt;strong&gt;%t %u&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;「次のフォルダに保存する」 &amp;#8211; 好きなフォルダ&lt;/li&gt;
&lt;li&gt;「同じ名前のファイルがあるときは上書きする」 &amp;#8211; &lt;strong&gt;チェックする&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次に、Selenium IDEのテストケースを作成します。Selenium IDEの基本的な使い方は 「&lt;a href=&#34;http://www.atmarkit.co.jp/fjava/rensai4/devtool07/devtool07_2.html&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://www.atmarkit.co.jp/fjava/rensai4/devtool07/devtool07_2.html&#39;, &#39;ブラウザを選ばずWebテストを自動化するSelenium (2/3) &amp;#8211; ＠IT&#39;]);&#34; title=&#34;ブラウザを選ばずWebテストを自動化するSelenium (2/3) - ＠IT&#34;&gt;ブラウザを選ばずWebテストを自動化するSelenium (&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt;) &amp;#8211; ＠IT&lt;/a&gt;」 が詳しいです。&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      コマンド
    &lt;/th&gt;
    
    &lt;th&gt;
      対象
    &lt;/th&gt;
    
    &lt;th&gt;
      値
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      open
    &lt;/td&gt;
    
    &lt;td&gt;
      /index.php
    &lt;/td&gt;
    
    &lt;td&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      windowFocus
    &lt;/td&gt;
    
    &lt;td&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      altKeyDown
    &lt;/td&gt;
    
    &lt;td&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      keyPress
    &lt;/td&gt;
    
    &lt;td&gt;
      //
    &lt;/td&gt;
    
    &lt;td&gt;
      \119
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      altKeyUp
    &lt;/td&gt;
    
    &lt;td&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;これが1ページぶんのオープン～キャプチャの流れです。&lt;/p&gt;

&lt;p&gt;ここまで設定したら、Selenium IDEの「現在のテストケースを実行」をクリックしてください。指定したURLが開き、先ほど指定したフォルダに画像が出力されていればOKです。&lt;/p&gt;

&lt;p&gt;あとは上記の要領で、「open」コマンドの対象を撮影したいページのアドレスに変更しながらコピペを繰り返してください。&lt;/p&gt;

&lt;h2 id=&#34;日本語を含むテストケースファイルが読み込めない場合:462da812d7d4ed2797cfbcdf095e949a&#34;&gt;日本語を含むテストケースファイルが読み込めない場合&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;XHTMLのヘッダを「xml:lang=&amp;#8221;en&amp;#8221; lang=&amp;#8221;en&amp;#8221;」から「xml:lang=&amp;#8221;ja&amp;#8221; lang=&amp;#8221;ja&amp;#8221;」に直す&lt;/li&gt;
&lt;li&gt;ファイル保存形式を「UTF-8 BOM無し」にする&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tips:462da812d7d4ed2797cfbcdf095e949a&#34;&gt;TIPS&lt;/h2&gt;

&lt;p&gt;カテゴリ毎に多くのコンテンツがあるようなページを連続キャプチャする場合、カテゴリ毎にテストケースを作成し、それをテストスイートに読み込ませると管理が便利（だと思います）。&lt;/p&gt;

&lt;h2 id=&#34;参考:462da812d7d4ed2797cfbcdf095e949a&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://d.hatena.ne.jp/szk-takanori/20071104/1194181489&#34; onclick=&#34;_gaq.push([&#39;_trackEvent&#39;, &#39;outbound-article&#39;, &#39;http://d.hatena.ne.jp/szk-takanori/20071104/1194181489&#39;, &#39;Seleniumでキャプチャを取得する拡張コマンド:captureScreenshot &amp;#8211; 現場のためのソフトウェア開発プロセス &amp;#8211; たかのり日記&#39;]);&#34; title=&#34;Seleniumでキャプチャを取得する拡張コマンド:captureScreenshot - 現場のためのソフトウェア開発プロセス - たかのり日記&#34;&gt;Seleniumでキャプチャを取得する拡張コマンド:captureScreenshot &amp;#8211; 現場のためのソフトウェア開発プロセス &amp;#8211; たかのり日記&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>